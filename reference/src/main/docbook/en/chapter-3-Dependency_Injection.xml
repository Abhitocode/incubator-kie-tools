<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="sid-5931402">
    
    <title>Dependency Injection</title>
    <para>
      The core Errai IOC module implements the
      <emphasis role="italics">
        <ulink url="http://download.oracle.com/otndocs/jcp/dependency_injection-1.0-final-oth-JSpec/">JSR-330 Dependency Injection</ulink>
      </emphasis>
      specification for in-client component wiring.
    </para>
    <para>Dependency injection (DI) allows for cleaner and more modular code, by permitting the implementation of decoupled and type-safe components. By using DI, components do not need to be aware of the implementation of provided services. Instead, they merely declare a contract with the container, which in turn provides instances of the services that component depends on.</para>
    <para>A simple example:</para>
    <informalexample>
      <programlisting language="java">public class MyLittleClass {
  private final TimeService timeService;

  @Inject
  public MyLittleClass(TimeService timeService) {
    this.timeService = timeService;
  }

  public void printTime() {
    System.out.println(this.timeService.getTime());
  }
}</programlisting>
    </informalexample>
    <para>
      In this example, we create a simple class which declares a dependency using
      <code>
        <ulink url="http://download.oracle.com/javaee/6/api/javax/inject/Inject.html">@Inject</ulink>
      </code>
      for the interface
      <code>TimeService</code>
      . In this particular case, we use constructor injection to establish the contract between the container and the component. We can similarly use field injection to the same effect:
    </para>
    <informalexample>
      <programlisting language="java">public class MyLittleClass {
  @Inject
  private TimeService timeService;

  public void printTime() {
    System.out.println(this.timeService.getTime());
  }
}</programlisting>
    </informalexample>
    <para>
      In order to inject
      <code>TimeService</code>
      , you must annotate it with
      <code>@ApplicationScoped</code>
      or the Errai DI container will not acknowledge the type as a bean.
    </para>
    <informalexample>
      <programlisting language="java">@ApplicationScoped
public class TimeService {
}</programlisting>
    </informalexample>
    <para>
      
    </para>
    <tip>
      <title>Best Practices</title>
      <para>Although field injection results in less code, a major disadvantage is that you cannot create immutable classes using the pattern, since the container must first call the default, no argument constructor, and then iterate through its injection tasks, which leaves the potential – albeit remote – that the object could be left in an partially or improperly initialized state. The advantage of constructor injection is that fields can be immutable (final), and invariance rules applied at construction time, leading to earlier failures, and the guarantee of consistent state.</para>
    </tip>
    <section id="sid-5931407">
      
      <title>Container Wiring</title>
      <para>
        In contrast to
        <ulink url="http://code.google.com/p/google-gin/">Gin</ulink>
        , the Errai IOC container does not provide a programmatic way of creating and configuring injectors. Instead, container-level binding rules are defined by implementing a
        <code>
          <ulink url="http://download.oracle.com/javaee/6/api/javax/inject/Provider.html">Provider</ulink>
        </code>
        , which is scanned for an auto-discovered by the container.
      </para>
      <para>
        A
        <code>Provider</code>
        is essentially a factory which produces dependent types in the container, which defers instantiation responsibility for the provided type to the provider implementation. Top-level providers use the standard
        <code>javax.inject.Provider&lt;T&gt;</code>
        interface.
      </para>
      <para>
        Types made available as
        <emphasis role="italics">top-level</emphasis>
        providers will be available for injection in any managed component within the container.
      </para>
      <para>Out of the box, Errai IOC implements three default top-level providers:</para>
      <itemizedlist>
        <listitem>
          <para>
            <code>org.jboss.errai.ioc.client.api.builtin.MessageBusProvider       :</code>
            Makes an instance of
            <code>MessageBus</code>
            available for injection.
          </para>
        </listitem>
        <listitem>
          <para>
            <code>org.jboss.errai.ioc.client.api.builtin.RequestDispatchProvider  :</code>
            Makes an instance of the
            <code>RequestDispatcher</code>
            available for injection.
          </para>
        </listitem>
        <listitem>
          <para>
            <code>org.jboss.errai.ioc.client.api.builtin.ConsumerProvider         :</code>
            Makes event
            <code>Consumer&lt;?&gt;</code>
            objects available for injection.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Implementing a
        <code>Provider</code>
        is relatively straight-forward. Consider the following two classes:
      </para>
      <para>
        <emphasis role="strong">TimeService.java</emphasis>
      </para>
      <informalexample>
        <programlisting language="java">public interface TimeService {
  public String getTime();
}</programlisting>
      </informalexample>
      <para>
        <emphasis role="strong">TimeServiceProvider.java</emphasis>
      </para>
      <informalexample>
        <programlisting language="java">@IOCProvider
@Singleton
public class TimeServiceProvider implements Provider&lt;TimeService&gt; {
  @Override
  public TimeService get() {
    return new TimeService() {
      public String getTime() {
        return "It's midnight somewhere!";
      }
    };
  }
}</programlisting>
      </informalexample>
      <para>If you are familiar with Guice, this is semantically identical to configuring an injector like so:</para>
      <informalexample>
        <programlisting language="java">Guice.createInjector(new AbstractModule() {
  public void configure() {
    bind(TimeService.class).toProvider(TimeServiceProvider.class);
  }
 }).getInstance(MyApp.class);</programlisting>
      </informalexample>
      <para>
        As shown in the above example code, the annotation
        <code>@IOCProvider</code>
        is used to denote top-level providers.
      </para>
      <para>The classpath will be searched for all annotated providers at compile time.</para>
      <important>
        <para>Top-level providers are treated as regular beans. And as such may inject dependencies – particularly from other top-level providers – as necessary.</para>
      </important>
    </section>
    <section id="sid-5931332">
      
      <title>Wiring server side components</title>
      <para>
        By default, ErraiBus uses Google Guice to wire components. However, we plan on standardizing on
        <emphasis role="italics">JSR-330 Dependency Injection</emphasis>
        specification in the near future. When deploying services on the server-side, it is currently possible to obtain references to the
        <code>MessageBus</code>
        ,
        <code>RequestDispatcher</code>
        , the
        <code>ErraiServiceConfigurator</code>
        , and
        <code>ErraiService</code>
        by declaring them as injection dependencies in Service classes, extension components, and session providers.
      </para>
    </section>
    <section id="sid-20938792">
      
      <title>Scopes</title>
      <para>
        Out of the box, the IOC container supports two bean scopes,
        <code>@Singleton</code>
        and
        <code>@EntryPoint</code>
        . Both of these scopes are roughly the same semantics. Since the client code is single-user and single-scope in nature, there is no general support for passivation scopes in the client.
      </para>
      <tip>
        <title>Note</title>
        <para>
          The Errai CDI extension module adds support for the
          <code>@Dependent</code>
          pseudo-scope and
          <code>@ApplicationScope</code>
          .
        </para>
      </tip>
    </section>
    <section id="sid-20938794">
      
      <title>Built-in Extensions</title>
      <section id="sid-20938797">
        
        <title>Bus Services</title>
        <para>As Errai IOC provides a container-based approach to client development, support for Errai services are exposed to the container so they may be injected and used throughout your application where appropriate. This section covers those services.</para>
        <section id="sid-20938797_BusServices-@Service">
          
          <title>@Service</title>
          <para>
            The
            <code>org.jboss.errai.bus.server.annotations.Service</code>
            annotation is used for binding service endpoints to the bus. Within the Errai IOC container you can annotate services and have them published to the bus on the client (or on the server) in a very straight-forward manner:
          </para>
          <example>
            <title>A simple message receiving service</title>
            <programlisting language="java">@Service
public class MyService implements MessageCallback {
  public void callback(Message message) {
    // ... //
  }
}</programlisting>
          </example>
          <para>Or like so ...</para>
          <example>
            <title>Mapping a callback from a field of a bean</title>
            <programlisting language="java">@Singleton
public class MyAppBean {
   @Service("MyService")
   private final MessageCallback myService = new MesageCallback() {
     public void callback(Message message) {
       // ... //
     }
   }
}</programlisting>
          </example>
          <para>As with server-side use of the annotation, if a service name is not explicitly specified, the underlying class name or field name being annotated will be used as the service name.</para>
        </section>
        <section id="sid-20938797_BusServices-@Local">
          
          <title>@Local</title>
          <para>
            The
            <code>org.jboss.errai.bus.server.api.Local</code>
            annotation is used in conjunction with the
            <code>@Service</code>
            annotation to advertise a service only for visibility on the local bus and thus, cannot receive messages across the wire for the service.
          </para>
          <example>
            <title>A local only service</title>
            <programlisting language="java">@Service @Local
public class MyLocalService implements MessageCallback {
  public void callback(Message message) {
    // ... //
  }
}</programlisting>
          </example>
        </section>
      </section>
      <section id="sid-20938800">
        
        <title>Client Components</title>
        <para>The IOC container, by default, provides a set of default injectable bean types. They range from basic services, to injectable proxies for RPC. This section covers the facilities available out-of-the-box.</para>
        <section id="sid-20938800_ClientComponents-MessageBus">
          
          <title>MessageBus</title>
          <para>
            The type
            <code>org.jboss.errai.bus.client.framework.MessageBus</code>
            is globally injectable into any bean. Injecting this type will provide the instance of the active message bus running in the client.
          </para>
          <example>
            <title>Injecting a MessageBus</title>
            <programlisting language="java">@Inject MessageBus bus;</programlisting>
          </example>
        </section>
        <section id="sid-20938800_ClientComponents-RequestDispatcher">
          
          <title>RequestDispatcher</title>
          <para>
            The type
            <code>org.jboss.errai.bus.client.framework.RequestDispatcher</code>
            is globally injectable into any bean. Injecting this type will provide a
            <code>RequestDispatcher</code>
            instance capable of delivering any messages provided to it, to the the
            <code>MessageBus</code>
            .
          </para>
          <example>
            <title>Injecting a RequestDispatcher</title>
            <programlisting language="java">@Inject RequestDispatcher dispatcher;</programlisting>
          </example>
        </section>
        <section id="sid-20938800_ClientComponents-Caller%3C%3F%3E">
          
          <title>Caller&lt;?&gt;</title>
          <para>
            The type
            <code>org.jboss.errai.ioc.client.api.Caller&lt;?&gt;</code>
            is a globally injectable RPC proxy. RPC proxies may be provided by various components. For example, JAX-RS or Errai RPC. The proxy itself is agnostic to the underlying RPC mechanism and is qualified by it's type parameterization.
          </para>
          <para>For example:</para>
          <example>
            <title>An example Caller&lt;?&gt; proxy</title>
            <programlisting language="java">public void MyClientBean {
  @Inject
  private Caller&lt;MyRpcInterface&gt; rpcCaller;
 
  // ... ///
  
  @UiHandler("button")
  public void onButtonClick(ClickHandler handler) { 
    rpcCaller.call(new RemoteCallback&lt;Void&gt;() {
      public void callback(Void void) {
      }
    ).callSomeMethod();
  }
}</programlisting>
          </example>
          <para>
            The above code shows the injection of a proxy for the RPC remote interface,
            <code>MyRpcInterface</code>
            . For more information on defining RPC proxies see
            <xref linkend="sid-5931313"/>
            and
            <xref linkend="sid-9470107"/>
            in Errai JAX-RS.
          </para>
        </section>
      </section>
      <section id="sid-21758082">
        
        <title>Lifecycle Tools</title>
        <para>A problem commonly associated with building large applications in the browser is ensuring that things happen in the proper order when code starts executing. Errai IOC provides you tools which permit you to ensure things happen before initialization, and forcing things to happen after initialization of all of the Errai services.</para>
        <section id="sid-21758082_LifecycleTools-ControllingStartup">
          
          <title>Controlling Startup</title>
          <para>
            In order to prevent initialization of the the bus and it's services so that you can do necessary configuration, especially if you are writing extensions to the Errai framework itself, you can create an implicit startup dependency on your bean by injecting an
            <code>org.jboss.errai.ioc.client.api.InitBallot&lt;?&gt;</code>
            .
          </para>
          <example>
            <title>Using an InitBallot to Control Startup</title>
            <programlisting language="java">@Singleton
public class MyClientBean {
  @Inject InitBallot&lt;MyClientBean&gt; ballot;

  @PostConstruct
  public void doStuff() {
    // ... do some work ...
    
    ballot.voteForInit();
  }
}</programlisting>
          </example>
        </section>
        <section id="sid-21758082_LifecycleTools-PerformingTasksAfterInitialization">
          
          <title>Performing Tasks After Initialization</title>
          <para>
            Sending RPC calls to the server from inside constructors and
            <code>@PostConstruct</code>
            methods in Errai is not always reliable due to the fact that the bus and RPC proxies initialize asynchronously with the rest of the application. Therefore it is often desirable to have such things happen in a post-initialization task, which is exposed in the
            <code>ClientMessageBus</code>
            API. However, it is much cleaner to use the
            <code>@AfterInitialization</code>
            annotation on one of your bean methods.
          </para>
          <example>
            <title>Using @AfterInitialization to do something after startup</title>
            <programlisting language="java">@Singleton
public class MyClientBean {
  @AfterInitialization
  public void doStuffAfterInit() {
    // ... do some work ...
  }
}</programlisting>
          </example>
        </section>
      </section>
    </section>
    <section id="sid-21627016">
      
      <title>Client-Side Bean Manager</title>
      <para>
        It may be necessary at times to obtain instances of beans managed by Errai IOC from outside the container managed scope or creating a hard dependency from your bean.  Errai IOC provides a simple client-side bean manager for handling these scenarios:
        <code>org.jboss.errai.ioc.client.container.IOCBeanManager</code>
        .
      </para>
      <para>As you might expect, you can inject the bean manager into any of your managed beans.</para>
      <example>
        <title>Injecting the client-side bean manager</title>
        <programlisting language="java">public MyManagedBean {
  @Inject IOCBeanManager manager;
   
  // class body 
}</programlisting>
      </example>
      <para>
        If you need to access the bean manager outside a managed bean, such as in a unit test, you can access it by calling
        <code>org.jboss.errai.ioc.client.container.IOC.getBeanManager()</code>
      </para>
      <para>
        <emphasis role="strong">Looking up Beans</emphasis>
      </para>
      <para>
        Looking up beans can be done through the use of the
        <code>lookupBean()</code>
        method in
        <code>IOCBeanManager</code>
        . Here's a basic example:
      </para>
      <example>
        <title>Example lookup of a bean</title>
        <programlisting language="java">public MyManagedBean {
  @Inject IOCBeanManager manager;
   
  public void lookupBean() {
    IOCBean&lt;SimpleBean&gt; bean = manager.lookupBean(SimpleBean.class);

    // check to see if the bean exists 
    if (bean != null) {
      // get the instance of the bean
      SimpleBean inst = bean.getInstance();
    }
  }
}</programlisting>
      </example>
      <para>
        In this example we lookup a bean class named
        <code>SimpleBean</code>
        . This example will succeed assuming that
        <code>SimpleBean</code>
        is unambiguous. If the bean is ambiguous and requires qualification, you can do a qualified lookup like so:
      </para>
      <example>
        <title>Looking up beans with qualifiers</title>
        <programlisting language="java">MyQualifier qual = new MyQualifier() {
  public annotationType() {
    return MyQualifier.class;
  }
}

MyOtherQualifier qual2 = new MyOtherQualifier() {
  public annotationType() {
    return MyOtherQualifier.class;
  }
}

// pass qualifiers to IOCBeanManager.lookupBean
IOCBean&lt;SimpleInterface&gt; bean = beanManager.lookupBean(SimpleBean.class, qual, qual2);</programlisting>
      </example>
      <para>In this example we manually construct instances of qualifier annotations in order to pass it to the bean manager for lookup. This is a necessary step since there's currently no support for annotation literals in Errai client code.</para>
    </section>
  </chapter>

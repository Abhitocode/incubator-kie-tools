<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V4.2//EN" "../docbookV4.2/docbookx.dtd">
<chapter id="bus">
    <title>Errai Bus</title>
    <sect1 id="bus-intro">
        <title>What is Errai Bus?</title>
        <para>
            ErraiBus forms the backbone of the Errai framework's approach to application design. Most
            importantly, it provides a straight-forward approach to a complex problem space. Providing
            common APIs across the client and server, developers will have no trouble working with complex
            messaging scenarios from building instant messaging clients, stock tickers, to monitoring
            instruments. There's no more messing with RPC APIs, or unweildy AJAX or COMET frameworks.
            We've built it all in to one, consice messaging framework. It's single-paradigm, and it's fun
            to work wit
        </para>
    </sect1>

    <sect1><title>Basic message exchange patterns</title>
        <sect2>
            <title>Receiving messages on the server side</title>
            <para>
                Every message has a sender and at least one receiver.
                A receiver is as it sounds--it receives the message and does something with it. Implementing a receiver (also referred to as a service) is as simple as implementing our standard MessageCallback interface,
                which is used pervasively across, both client and server code.
                Let's begin with server side component that receives messages:

                <programlisting>
@Service("HelloWorldService")
public class HelloWorldService implements MessageCallback {
    public void callback(CommandMessage message) {
        System.out.println("Hello, World!");
    }
}
                </programlisting>
            </para>
        </sect2>

        <sect2>
            <title>Sending messages from a client</title>
            <para>
                In order to send a message from a client you need to create a CommandMessage
                and send it through an instance of MessageBus. In this simple example we send it to
                the subject 'HelloWorldService'
                <programlisting>
public class HelloWorld implements EntryPoint {

    // Get an instance of the MessageBus
    private MessageBus bus = ErraiBus.get();

    public void onModuleLoad() {
        Button button = new Button("Send message");

        button.addClickHandler(new ClickHandler() {

        public void onClick(ClickEvent event) {
            // Send a message to the 'HelloWorldService'.
            CommandMessage.create()
                .toSubject("HelloWorldService")
                .sendNowWith(bus);
                }
        });

        [...]
     }
}
                </programlisting>
            </para>
        </sect2>

        <sect2>
            <title>Sending messages to a client</title>
            <para>
                In the following example we extend our server side component
                to reply with a message when the callback method is invoked.
                It will create a CommadnMessage and address it to the subject 'HelloWorldClient':
                
                <programlisting>
@Service("HelloWorldService")
public class HelloWorldService implements MessageCallback {

    private MessageBus bus;

    @Inject
    public HelloWorldService(MessageBus bus) {
        this.bus = bus;
    }

    public void callback(CommandMessage message) {
            // Send a message to the 'HelloWorldClient'.
            CommandMessage.create()
                .toSubject("HelloWorldClient")
                .set("text", "Hi There")
                .sendNowWith(bus);
                }
        });
    }
}               
                </programlisting>

                <tip>
                    <title>The @Inject annotation</title>
                    <para>
                    Confused about the @Inject annotation? Take a look at the
                    section about wiring server side components.
                    </para>
                </tip>
            </para>

        </sect2>

        <sect2>
            <title>Receiving messages on the client side</title>
            <para>
             If a client needs to receive messages that are "pushed" from the server side
             it needs to register a listener on a certain subject.      
             <programlisting>

public class HelloWorld implements EntryPoint {
    private MessageBus bus = ErraiBus.get();

    public void onModuleLoad() {
    [...]
                 
    /**
    * Declare a local service to receive messages on the subject
    * "HelloWorldClient".
    */
    bus.subscribe("BroadcastReceiver", new MessageCallback() {
        public void callback(CommandMessage message) {
            /**
            * When a message arrives, extract the "text" field and
            * do something with it
            */
            String messageText = message.get(String.class, "text");
        }
    });

    [...]                 
}
             </programlisting>
            </para>

        </sect2>

    </sect1>

    <sect1>
        <title>Advanced messaging scenarios</title>
        <sect2>
            <title>Broadcasting messages</title>
        </sect2>
        <sect2>
            <title>Conversational message exchange</title>
        </sect2>
    </sect1>

    <sect1>
        <title>Message payload and serialization</title>
        <para>
            How does the low level API work and how should people
            work with domain models.            
        </para>
    </sect1>

    <sect1 id="wiring">
        <title>Wiring server side components</title>
        <para>
         Put some explanation about the guice integration here.   
        </para>
    </sect1>

     <sect1>
        <title>Bus configuration</title>
         <para>
             Explain ErraiService.properties and ErraiApp.properties
         </para>
    </sect1>
</chapter>
